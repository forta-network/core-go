// Code generated by MockGen. DO NOT EDIT.
// Source: store/dynamo/store.go

// Package mock_dynamo is a generated GoMock package.
package mock_dynamo

import (
	context "context"
	reflect "reflect"

	dynamo "github.com/forta-network/core-go/store/dynamo"
	gomock "github.com/golang/mock/gomock"
)

// MockItem is a mock of Item interface.
type MockItem struct {
	ctrl     *gomock.Controller
	recorder *MockItemMockRecorder
}

// MockItemMockRecorder is the mock recorder for MockItem.
type MockItemMockRecorder struct {
	mock *MockItem
}

// NewMockItem creates a new mock instance.
func NewMockItem(ctrl *gomock.Controller) *MockItem {
	mock := &MockItem{ctrl: ctrl}
	mock.recorder = &MockItemMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockItem) EXPECT() *MockItemMockRecorder {
	return m.recorder
}

// GetPartitionKeyName mocks base method.
func (m *MockItem) GetPartitionKeyName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPartitionKeyName")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetPartitionKeyName indicates an expected call of GetPartitionKeyName.
func (mr *MockItemMockRecorder) GetPartitionKeyName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPartitionKeyName", reflect.TypeOf((*MockItem)(nil).GetPartitionKeyName))
}

// GetSortKeyName mocks base method.
func (m *MockItem) GetSortKeyName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSortKeyName")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetSortKeyName indicates an expected call of GetSortKeyName.
func (mr *MockItemMockRecorder) GetSortKeyName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSortKeyName", reflect.TypeOf((*MockItem)(nil).GetSortKeyName))
}

// MockCache is a mock of Cache interface.
type MockCache[I dynamo.Item] struct {
	ctrl     *gomock.Controller
	recorder *MockCacheMockRecorder[I]
}

// MockCacheMockRecorder is the mock recorder for MockCache.
type MockCacheMockRecorder[I dynamo.Item] struct {
	mock *MockCache[I]
}

// NewMockCache creates a new mock instance.
func NewMockCache[I dynamo.Item](ctrl *gomock.Controller) *MockCache[I] {
	mock := &MockCache[I]{ctrl: ctrl}
	mock.recorder = &MockCacheMockRecorder[I]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCache[I]) EXPECT() *MockCacheMockRecorder[I] {
	return m.recorder
}

// Get mocks base method.
func (m *MockCache[I]) Get(ctx context.Context, partitionKey string, sortKey ...string) (*I, bool) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, partitionKey}
	for _, a := range sortKey {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].(*I)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCacheMockRecorder[I]) Get(ctx, partitionKey interface{}, sortKey ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, partitionKey}, sortKey...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCache[I])(nil).Get), varargs...)
}

// GetQuery mocks base method.
func (m *MockCache[I]) GetQuery(ctx context.Context, queryKey string) ([]*I, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetQuery", ctx, queryKey)
	ret0, _ := ret[0].([]*I)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// GetQuery indicates an expected call of GetQuery.
func (mr *MockCacheMockRecorder[I]) GetQuery(ctx, queryKey interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetQuery", reflect.TypeOf((*MockCache[I])(nil).GetQuery), ctx, queryKey)
}

// Put mocks base method.
func (m *MockCache[I]) Put(ctx context.Context, item *I, partitionKey string, sortKey ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, item, partitionKey}
	for _, a := range sortKey {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Put", varargs...)
}

// Put indicates an expected call of Put.
func (mr *MockCacheMockRecorder[I]) Put(ctx, item, partitionKey interface{}, sortKey ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, item, partitionKey}, sortKey...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Put", reflect.TypeOf((*MockCache[I])(nil).Put), varargs...)
}

// PutQuery mocks base method.
func (m *MockCache[I]) PutQuery(ctx context.Context, queryKey string, items []*I) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PutQuery", ctx, queryKey, items)
}

// PutQuery indicates an expected call of PutQuery.
func (mr *MockCacheMockRecorder[I]) PutQuery(ctx, queryKey, items interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PutQuery", reflect.TypeOf((*MockCache[I])(nil).PutQuery), ctx, queryKey, items)
}

// MockStore is a mock of Store interface.
type MockStore[I dynamo.Item] struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder[I]
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder[I dynamo.Item] struct {
	mock *MockStore[I]
}

// NewMockStore creates a new mock instance.
func NewMockStore[I dynamo.Item](ctrl *gomock.Controller) *MockStore[I] {
	mock := &MockStore[I]{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder[I]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore[I]) EXPECT() *MockStoreMockRecorder[I] {
	return m.recorder
}

// Delete mocks base method.
func (m *MockStore[I]) Delete(ctx context.Context, item *I, partitionKey string, sortKey ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, item, partitionKey}
	for _, a := range sortKey {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockStoreMockRecorder[I]) Delete(ctx, item, partitionKey interface{}, sortKey ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, item, partitionKey}, sortKey...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockStore[I])(nil).Delete), varargs...)
}

// Get mocks base method.
func (m *MockStore[I]) Get(ctx context.Context, partitionKey string, sortKey ...string) (*I, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, partitionKey}
	for _, a := range sortKey {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].(*I)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockStoreMockRecorder[I]) Get(ctx, partitionKey interface{}, sortKey ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, partitionKey}, sortKey...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockStore[I])(nil).Get), varargs...)
}

// GetAll mocks base method.
func (m *MockStore[I]) GetAll(ctx context.Context, partitionKey string) ([]*I, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAll", ctx, partitionKey)
	ret0, _ := ret[0].([]*I)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAll indicates an expected call of GetAll.
func (mr *MockStoreMockRecorder[I]) GetAll(ctx, partitionKey interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockStore[I])(nil).GetAll), ctx, partitionKey)
}

// GetAllFromIndex mocks base method.
func (m *MockStore[I]) GetAllFromIndex(ctx context.Context, indexName, partitionKeyName, partitionKeyVal string) ([]*I, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllFromIndex", ctx, indexName, partitionKeyName, partitionKeyVal)
	ret0, _ := ret[0].([]*I)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllFromIndex indicates an expected call of GetAllFromIndex.
func (mr *MockStoreMockRecorder[I]) GetAllFromIndex(ctx, indexName, partitionKeyName, partitionKeyVal interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllFromIndex", reflect.TypeOf((*MockStore[I])(nil).GetAllFromIndex), ctx, indexName, partitionKeyName, partitionKeyVal)
}

// Put mocks base method.
func (m *MockStore[I]) Put(ctx context.Context, item *I, conditionExpression ...dynamo.ConditionExpression) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, item}
	for _, a := range conditionExpression {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Put", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Put indicates an expected call of Put.
func (mr *MockStoreMockRecorder[I]) Put(ctx, item interface{}, conditionExpression ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, item}, conditionExpression...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Put", reflect.TypeOf((*MockStore[I])(nil).Put), varargs...)
}

// TableName mocks base method.
func (m *MockStore[I]) TableName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TableName")
	ret0, _ := ret[0].(string)
	return ret0
}

// TableName indicates an expected call of TableName.
func (mr *MockStoreMockRecorder[I]) TableName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TableName", reflect.TypeOf((*MockStore[I])(nil).TableName))
}

// WithCache mocks base method.
func (m *MockStore[I]) WithCache(cache dynamo.Cache[I]) dynamo.Store[I] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithCache", cache)
	ret0, _ := ret[0].(dynamo.Store[I])
	return ret0
}

// WithCache indicates an expected call of WithCache.
func (mr *MockStoreMockRecorder[I]) WithCache(cache interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithCache", reflect.TypeOf((*MockStore[I])(nil).WithCache), cache)
}
